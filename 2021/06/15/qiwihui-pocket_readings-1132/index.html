<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pocket.qiwihui.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="io_uring 的接口与实现">
<meta property="og:type" content="article">
<meta property="og:title" content="io_uring 的接口与实现">
<meta property="og:url" content="http://pocket.qiwihui.com/2021/06/15/qiwihui-pocket_readings-1132/index.html">
<meta property="og:site_name" content="Pocket Readings">
<meta property="og:description" content="io_uring 的接口与实现">
<meta property="og:image" content="https://www.skyzh.dev/memory_mapping.png">
<meta property="og:image" content="https://www.skyzh.dev/sqe_submit.png">
<meta property="og:image" content="https://www.skyzh.dev/cqe_retrieve.png">
<meta property="og:image" content="https://www.skyzh.dev/callgraph_waterfall_iowq.png">
<meta property="og:image" content="https://www.skyzh.dev/flamegraph_iowq.png">
<meta property="og:image" content="https://www.skyzh.dev/callgraph_waterfall_iopoll.png">
<meta property="og:image" content="https://www.skyzh.dev/flamegraph_iopoll.png">
<meta property="og:image" content="https://www.skyzh.dev/submit_lifecycle.png">
<meta property="article:published_time" content="2021-06-15T02:21:10.000Z">
<meta property="article:modified_time" content="2021-07-21T13:58:31.406Z">
<meta property="article:author" content="qiwihui">
<meta property="article:tag" content="fetched">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.skyzh.dev/memory_mapping.png">

<link rel="canonical" href="http://pocket.qiwihui.com/2021/06/15/qiwihui-pocket_readings-1132/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>io_uring 的接口与实现 | Pocket Readings</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pocket Readings</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人阅读清单记录博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pocket.qiwihui.com/2021/06/15/qiwihui-pocket_readings-1132/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qiwihui">
      <meta itemprop="description" content="个人阅读清单记录博客，并不代表个人观点。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pocket Readings">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          io_uring 的接口与实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-15 02:21:10" itemprop="dateCreated datePublished" datetime="2021-06-15T02:21:10+00:00">2021-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-21 13:58:31" itemprop="dateModified" datetime="2021-07-21T13:58:31+00:00">2021-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">2019阅读</span></a>
                </span>
            </span>

          
            <div class="post-description">io_uring 的接口与实现</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>io_uring &#26159; Linux &#25552;&#20379;&#30340;&#19968;&#20010;&#24322;&#27493; I/O &#25509;&#21475;&#12290;io_uring &#22312; 2019 &#24180;&#21152;&#20837; Linux &#20869;&#26680;&#65292;&#32463;&#36807;&#20102;&#20004;&#24180;&#30340;&#21457;&#23637;&#65292;&#29616;&#22312;&#24050;&#32463;&#21464;&#24471;&#38750;&#24120;&#24378;&#22823;&#12290;&#26412;&#25991;&#22522;&#20110; Linux 5.12.10 &#20171;&#32461; io_uring &#25509;&#21475;&#12290;<br><br><br><br>Tags:<br><br><br><br>via Pocket <a href="https://ift.tt/2TXw0KK" target="_blank" rel="noopener">https://ift.tt/2TXw0KK</a> original site<br><br><br><br>June 15, 2021 at 09:45AM</p>
<h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><hr>
<blockquote>
<p>from: <a href="https://github.com/qiwihui/pocket_readings/issues/1132#issuecomment-861119934" target="_blank" rel="noopener"><strong>github-actions[bot]</strong></a> on: <strong>6/15/2021</strong></p>
</blockquote>
<h2 id="io-uring-的接口与实现"><a href="#io-uring-的接口与实现" class="headerlink" title="io_uring 的接口与实现"></a>io_uring 的接口与实现</h2><p>14 Jun 2021</p>
<h1 id="io-uring-的接口与实现-1"><a href="#io-uring-的接口与实现-1" class="headerlink" title="io_uring 的接口与实现"></a>io_uring 的接口与实现</h1><ul>
<li><a href="https://www.skyzh.dev/#%E5%89%8D%E8%A8%80" target="_blank" rel="noopener">前言</a></li>
<li><a href="https://www.skyzh.dev/#io_uring-%E7%9A%84-%E7%94%A8%E6%88%B7%E6%80%81-api" target="_blank" rel="noopener">io_uring 的 用户态 API</a><ul>
<li><a href="https://www.skyzh.dev/#%E5%88%9D%E5%A7%8B%E5%8C%96-io_uring" target="_blank" rel="noopener">初始化 io_uring</a></li>
<li><a href="https://www.skyzh.dev/#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">任务的描述</a></li>
<li><a href="https://www.skyzh.dev/#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4%E4%B8%8E%E5%AE%8C%E6%88%90" target="_blank" rel="noopener">任务的提交与完成</a></li>
</ul>
</li>
<li><a href="https://www.skyzh.dev/#io_uring-%E7%9A%84%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">io_uring 的实现</a><ul>
<li><a href="https://www.skyzh.dev/#%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">基于内核线程的任务执行</a></li>
<li><a href="https://www.skyzh.dev/#%E5%9F%BA%E4%BA%8E%E8%BD%AE%E8%AF%A2%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">基于轮询的任务执行</a></li>
</ul>
</li>
<li><a href="https://www.skyzh.dev/#io_uring-%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">io_uring 的任务依赖管理</a></li>
<li><a href="https://www.skyzh.dev/#%E9%99%84%E5%BD%95" target="_blank" rel="noopener">附录</a><ul>
<li><a href="https://www.skyzh.dev/#%E4%BD%BF%E7%94%A8-fio-%E7%9A%84-io_uring-%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">使用 fio 的 io_uring 模式进行测试</a></li>
<li><a href="https://www.skyzh.dev/#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">相关链接</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>io_uring</code> 是 Linux 提供的一个异步 I/O <code>接口。io_uring</code> 在 2019 年加入 Linux 内核，经过了两年的发展，现在已经变得非常强大。本文基于 Linux 5.12.10 介绍 <code>io_uring</code> 接口。</p>
<p><code>io_uring</code> 的实现主要在 <a href="https://elixir.bootlin.com/linux/v5.12.10/source/fs/io_uring.c" target="_blank" rel="noopener"><code>fs/io_uring.c</code></a> 中。</p>
<h2 id="io-uring-的-用户态-API"><a href="#io-uring-的-用户态-API" class="headerlink" title="io_uring 的 用户态 API"></a>io_uring 的 用户态 API</h2><p><code>io_uring</code> 的实现仅仅使用了三个 syscall：<code>io_uring_setup</code>, <code>io_uring_enter</code> 和 <code>io_uring_register</code>。它们分别用于设置 <code>io_uring</code> 上下文，提交并获取完成任务，以及注册内核用户共享的缓冲区。使用前两个 syscall 已经足够使用 <code>io_uring</code> 接口了。</p>
<p>用户和内核通过提交队列和完成队列进行任务的提交和收割。后文中会出现大量的简写，在这里先做一些介绍。</p>
<p>缩略语</p>
<p>英语</p>
<p>中文</p>
<p>解析</p>
<p>SQ</p>
<p>Submission Queue</p>
<p>提交队列</p>
<p>一整块连续的内存空间存储的环形队列。<br>用于存放将执行操作的数据。</p>
<p>CQ</p>
<p>Completion Queue</p>
<p>完成队列</p>
<p>一整块连续的内存空间存储的环形队列。<br>用于存放完成操作返回的结果。</p>
<p>SQE</p>
<p>Submission Queue Entry</p>
<p>提交队列项</p>
<p>提交队列中的一项。</p>
<p>CQE</p>
<p>Completion Queue Entry</p>
<p>完成队列项</p>
<p>完成队列中的一项。</p>
<p>Ring</p>
<p>Ring</p>
<p>环</p>
<p>比如 SQ Ring，就是“提交队列信息”的意思。<br>包含队列数据、队列大小、丢失项等等信息。</p>
<h3 id="初始化-io-uring"><a href="#初始化-io-uring" class="headerlink" title="初始化 io_uring"></a>初始化 io_uring</h3><pre><code>long io_uring_setup(u32 entries, struct io_uring_params __user *params)</code></pre><p>用户通过调用 <code>io_uring_setup</code> <a href="https://www.skyzh.dev/#fn:1" target="_blank" rel="noopener">1</a> 初始化一个新的 <code>io_uring</code> 上下文。该函数返回一个 file descriptor，并将 <code>io_uring</code> 支持的功能、以及各个数据结构在 <code>fd</code> 中的偏移量存入 <code>params</code>。用户根据偏移量将 <code>fd</code> 映射到内存 (mmap) 后即可获得一块内核用户共享的内存区域。这块内存区域中，有 <code>io_uring</code> 的上下文信息：提交队列信息 (<code>SQ_RING</code>) 和完成队列信息 (<code>CQ_RING</code>)；还有一块专门用来存放提交队列元素的区域 (SQEs)。<code>SQ_RING</code> 中只存储 SQE 在 SQEs 区域中的序号，<code>CQ_RING</code> 存储完整的任务完成数据。<a href="https://www.skyzh.dev/#fn:2" target="_blank" rel="noopener">2</a></p>
<p><img src="https://www.skyzh.dev/memory_mapping.png" alt="Memory Mapping of io_uring_setup"></p>
<p>在 Linux 5.12 中，SQE 大小为 64B，CQE 大小为 16B。因此，相同数量的 SQE 和 CQE 所需要的空间不一样。初始化 <code>io_uring</code> 时，用户如果不在 <code>params</code> 中设置 CQ 长度，内核会分配 <code>entries</code> 个 SQE，以及 <code>entries * 2</code> 个 CQE。</p>
<p><code>io_uring_setup</code> 设计的巧妙之处在于，内核通过一块和用户共享的内存区域进行消息的传递。在创建上下文后，任务提交、任务收割等操作都通过这块共享的内存区域进行，在 <code>IO_SQPOLL</code> 模式下（后文将详细介绍），可以完全绕过 Linux 的 syscall 机制完成需要内核介入的操作（比如读写文件），大大减少了 syscall 切换上下文、刷 TLB 的开销。</p>
<h3 id="任务的描述"><a href="#任务的描述" class="headerlink" title="任务的描述"></a>任务的描述</h3><p><code>io_uring</code> 可以处理多种 I/O 相关的请求。比如：</p>
<ul>
<li>文件相关：read, write, open, fsync, fallocate, fadvise, close</li>
<li>网络相关：connect, accept, send, recv, epoll_ctl</li>
<li>等等</li>
</ul>
<p>下面以 <code>fsync</code> 为例，介绍执行这个操作中可能用到的结构体和函数。</p>
<h4 id="操作的定义与实现"><a href="#操作的定义与实现" class="headerlink" title="操作的定义与实现"></a>操作的定义与实现</h4><p><code>io_op_def io_op_defs[]</code> 数组中定义了 <code>io_uring</code> 支持的操作，以及它在 <code>io_uring</code> 中的一些参数。<a href="https://www.skyzh.dev/#fn:3" target="_blank" rel="noopener">3</a> 比如 <code>IORING_OP_FSYNC</code>：</p>
<pre><code>static const struct io_op_def io_op_defs[] = {
        ...
        [IORING_OP_FSYNC] = {
                .needs_file        = 1,
        },
        ...</code></pre><p><code>io_uring</code> 中几乎每个操作都有对应的准备和执行函数。比如 <code>fsync</code> 操作就对应 <code>io_fsync_prep</code> 和 <code>io_fsync</code> 函数。</p>
<pre><code>static int io_fsync_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
static int io_fsync(struct io_kiocb *req, unsigned int issue_flags);</code></pre><p>除了 <code>fsync</code> 这种同步（阻塞）操作，内核中还支持一些异步（非阻塞）调用的操作，比如 Direct I/O 模式下的文件读写。对于这些操作，<code>io_uring</code> 中还会有一个对应的异步准备函数，以 <code>_async</code> 结尾。比如：</p>
<pre><code>static inline int io_rw_prep_async(struct io_kiocb *req, int rw);</code></pre><p>这些函数就是 <code>io_uring</code> 对某个 I/O 操作的包装。</p>
<h4 id="操作信息的传递"><a href="#操作信息的传递" class="headerlink" title="操作信息的传递"></a>操作信息的传递</h4><p>用户将需要进行的操作写入 <code>io_uring</code> 的 SQ 中。在 CQ 中，用户可以收割任务的完成情况。这里，我们介绍 SQE 和 CQE 的编码。</p>
<p><code>include/uapi/linux/io_uring.h</code> <a href="https://www.skyzh.dev/#fn:4" target="_blank" rel="noopener">4</a> 中定义了 SQE 和 CQE。SQE 是一个 64B 大小的结构体，里面包含了所有操作可能用到的信息。</p>
<p>`io_uring_sqe` 的定义</p>
<pre><code>struct io_uring_sqe {
        __u8    opcode;        /* type of operation for this sqe */
        __u8    flags;        /* IOSQE_ flags */
        __u16    ioprio;        /* ioprio for the request */
        __s32    fd;        /* file descriptor to do IO on */
        union {
                __u64    off;    /* offset into file */
                __u64    addr2;
        };
        union {
                __u64    addr;    /* pointer to buffer or iovecs */
                __u64    splice_off_in;
        };
        __u32    len;        /* buffer size or number of iovecs */
        union {
                __kernel_rwf_t    rw_flags;
                __u32        fsync_flags;
                ...
        };
        __u64    user_data;    /* data to be passed back at completion time */
        union {
        ...
        };
};</code></pre><p>CQE 是一个 16B 大小的结构体，包含操作的执行结果。</p>
<pre><code>struct io_uring_cqe {
        __u64    user_data;    /* sqe-&gt;data submission passed back */
        __s32    res;        /* result code for this event */
        __u32    flags;
};</code></pre><p>继续以 <code>fsync</code> 为例。要在 <code>io_uring</code> 中完成 <code>fsync</code> 操作，用户需要将 SQE 中的 <code>opcode</code> 设置为 <code>IORING_OP_FSYNC</code>，将 <code>fd</code> 设置为需要同步的文件，并填充 <code>fsync_flags</code>。其他操作也是类似，设置 opcode 并将操作所需要的参数并写入 SQE 即可。</p>
<p>通常来说，使用 <code>io_uring</code> 的程序都需要用到 64 位的 <code>user_data</code> 来唯一标识一个操作 <a href="https://www.skyzh.dev/#fn:5" target="_blank" rel="noopener">5</a>。<code>user_data</code> 是 SQE 的一部分。<code>io_uring</code> 执行完某个操作后，会将这个操作的 <code>user_data</code> 和操作的返回值一起写入 CQ 中。</p>
<h3 id="任务的提交与完成"><a href="#任务的提交与完成" class="headerlink" title="任务的提交与完成"></a>任务的提交与完成</h3><p><code>io_uring</code> 通过环形队列和用户交互。</p>
<p><img src="https://www.skyzh.dev/sqe_submit.png" alt="Submit SQE"></p>
<p>我们的先以用户提交任务为例，介绍 <code>io_uring</code> 的内核用户交互方式。用户提交任务的过程如下：</p>
<ul>
<li>将 SQE 写入 SQEs 区域，而后将 SQE 编号写入 SQ。（对应图中绿色第一步）</li>
<li>更新用户态记录的队头。（对应图中绿色第二步）</li>
<li>如果有多个任务需要同时提交，用户不断重复上面的过程。</li>
<li>将最终的队头编号写入与内核共享的 io_uring 上下文。（对应图中绿色第三步）</li>
</ul>
<p>接下来我们简要介绍内核获取任务、内核完成任务、用户收割任务的过程。</p>
<ul>
<li>内核态获取任务的方式是，从队尾读取 SQE，并更新 io_uring 上下文的 SQ tail。</li>
</ul>
<p><img src="https://www.skyzh.dev/cqe_retrieve.png" alt="Retrieve CQE"></p>
<ul>
<li>内核态完成任务：往 CQ 中写入 CQE，更新上下文 CQ head。</li>
<li>用户态收割任务：从 CQ 中读取 CQE，更新上下文 CQ tail。</li>
</ul>
<h2 id="io-uring-的实现"><a href="#io-uring-的实现" class="headerlink" title="io_uring 的实现"></a>io_uring 的实现</h2><p>介绍完 <code>io_uring</code> 的用户态接口后，我们就可以详细介绍 <code>io_uring</code> 在内核中是如何实现的了。</p>
<p><code>io_uring</code> 在创建时有两个选项，对应着 <code>io_uring</code> 处理任务的不同方式：</p>
<ul>
<li>开启 <code>IORING_SETUP_IOPOLL</code> 后，<code>io_uring</code> 会使用轮询的方式执行所有的操作。</li>
<li>开启 <code>IORING_SETUP_SQPOLL</code> 后，<code>io_uring</code> 会创建一个内核线程专门用来收割用户提交的任务。</li>
</ul>
<p>这些选项的设定会影响之后用户与 <code>io_uring</code> 交互的方式：</p>
<ul>
<li>都不开启，通过 <code>io_uring_enter</code> 提交任务，收割任务无需 syscall。</li>
<li>只开启 <code>IORING_SETUP_IOPOLL</code>，通过 <code>io_uring_enter</code> 提交任务和收割任务。</li>
<li>开启 <code>IORING_SETUP_SQPOLL</code>，无需任何 syscall 即可提交、收割任务。内核线程在一段时间无操作后会休眠，可以通过 <code>io_uring_enter</code> 唤醒。</li>
</ul>
<h3 id="基于内核线程的任务执行"><a href="#基于内核线程的任务执行" class="headerlink" title="基于内核线程的任务执行"></a>基于内核线程的任务执行</h3><p>每个 <code>io_uring</code> 都由一个轻量级的 io-wq<a href="https://www.skyzh.dev/#fn:6" target="_blank" rel="noopener">6</a> 线程池支持，从而实现 Buffered I/O 的异步执行。对于 Buffered I/O 来说，文件的内容可能在 page cache 里，也可能需要从盘上读取。如果文件的内容已经在 page cache 中，这些内容可以直接在 <code>io_uring_enter</code> 的时候读取到，并在返回用户态时收割。否则，读写操作会在 workqueue 里执行。</p>
<p>如果没有在创建 <code>io_uring</code> 时指定 <code>IORING_SETUP_IOPOLL</code> 选项，<code>io_uring</code> 的操作就会放进 io-wq 中执行。</p>
<p><img src="https://www.skyzh.dev/callgraph_waterfall_iowq.png" alt="Callgraph Waterfall when io-wq enabled"></p>
<p>上图覆盖了关闭 <code>IOPOLL</code> 模式下，用户通过 <code>io_uring</code> 执行操作的整个调用流程。用户提交的 SQE 经过一系列处理后，会在 <code>io_queue_sqe</code> 中试探着执行一次。</p>
<ul>
<li>如果在 SQE 中指定了 <code>IOSQE_ASYNC</code> 选项，该操作会直接被放入 io-wq 队列。</li>
<li>如果没有指定 <code>IOSQE_ASYNC</code> 选项，<code>io_uring</code> 会先用非阻塞模式尝试执行一次 SQE 中包含的操作。举个例子：执行 <code>io_read</code> 时，如果数据已经在 page cache 里面，非阻塞模式的 <code>io_read</code> 操作就会成功。如果成功，则直接返回。如果不成功，放入 io-wq 中。</li>
</ul>
<p>之后，Linux 随时会调度 io-wq 的内核线程执行。此时，<code>io_wq_submit_work</code> 函数会不断用阻塞模式执行用户指定的操作。某个操作完整执行后，它的返回值就会被写入 CQ 中。用户通过 <code>io_uring</code> 上下文中的 CQ 队尾位置就能知道内核处理好了哪些操作，无需再次调用 <code>io_uring_enter</code>。</p>
<p><img src="https://www.skyzh.dev/flamegraph_iowq.png" alt="Flamegraph when io-wq enabled"></p>
<p>通过火焰图可以观察到，在关闭 IOPOLL 时，内核会花大量时间处理读取操作。</p>
<h3 id="基于轮询的任务执行"><a href="#基于轮询的任务执行" class="headerlink" title="基于轮询的任务执行"></a>基于轮询的任务执行</h3><p>创建 <code>io_uring</code> 时指定 <code>IORING_SETUP_IOPOLL</code> 选项即可开启 I/O 轮询模式。通常来说，用 <code>O_DIRECT</code> 模式打开的文件支持使用轮询模式读写内容，执行 read / write 操作。</p>
<p>在轮询模式下，<code>io_uring_enter</code> 只负责把操作提交到内核的文件读写队列中。之后，用户需要多次调用 <code>io_uring_enter</code> 来轮询操作是否完成。</p>
<p><img src="https://www.skyzh.dev/callgraph_waterfall_iopoll.png" alt="Callgraph Waterfall in IOPOLL mode"></p>
<p>在轮询模式下，io-wq 不会被使用。提交任务时，<code>io_read</code> 直接调用内核的 Direct I/O 接口向设备队列提交任务。收割任务时，<code>io_iopoll_check</code> 会直接调用内核接口轮询任务是否完成。</p>
<p><img src="https://www.skyzh.dev/flamegraph_iopoll.png" alt="Flamegraph in IOPOLL mode"></p>
<p>通过火焰图可以看到，<code>io_uring_enter</code> 在提交任务这一块只花了一小部分时间。大部分时间都在轮询 I/O 操作是否完成。</p>
<h2 id="io-uring-的任务依赖管理"><a href="#io-uring-的任务依赖管理" class="headerlink" title="io_uring 的任务依赖管理"></a>io_uring 的任务依赖管理</h2><p>在实际生产环境中，我们往往会有这样的需求：往文件中写入 n 次，然后用 <code>fsync</code> 落盘。在使用 <code>io_uring</code> 时，SQ 中的任务不一定会按顺序执行。给操作设定 <code>IO_SQE_LINK</code> 选项，就可以建立任务之间的先后关系。<code>IO_SQE_LINK</code> 之后的第一个任务一定在当前任务完成后执行。<a href="https://www.skyzh.dev/#fn:7" target="_blank" rel="noopener">7</a></p>
<p><img src="https://www.skyzh.dev/submit_lifecycle.png" alt="Task Link"></p>
<p><code>io_uring</code> 内部使用链表来管理任务的依赖关系。每一个操作在经过 <code>io_submit_sqe</code> 的处理后，都会变成一个 <code>io_kiocb</code> 对象。这个对象有可能会被放入链表中。<code>io_submit_sqe</code> <a href="https://www.skyzh.dev/#fn:8" target="_blank" rel="noopener">8</a> 会对含有 <code>IO_SQE_LINK</code> 的 SQE 作特殊处理，处理过程如下：</p>
<ul>
<li>当前链表为空（之前的任务都没有 <code>IO_SQE_LINK</code>，或处理完了一个链），当前任务 <code>IO_SQE_LINK</code>，则创建一个新链表。</li>
<li>链表已经被创建，新来的任务依然是 <code>IO_SQE_LINK</code>，则将当前任务放进链表。</li>
<li>链表已经被创建，当前处理的任务没有 <code>IO_SQE_LINK</code>，将当前任务放入链表，并开始按顺序处理整个链表的操作。</li>
</ul>
<p>由此看来，SQ 中连续的 <code>IO_SQE_LINK</code> 记录会按先后关系依次处理。在 <code>io_submit_sqes</code> 结束前，所有的任务都会被提交。因此，如果任务有先后关系，它们必须在同一个 <code>io_uring_enter</code> syscall 中批量提交。</p>
<p>其他用于控制 <code>io_uring</code> 任务依赖的选项包括 <code>IOSQE_IO_DRAIN</code> 和 <code>IOSQE_IO_HARDLINK</code>，这里不再展开。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="使用-fio-的-io-uring-模式进行测试"><a href="#使用-fio-的-io-uring-模式进行测试" class="headerlink" title="使用 fio 的 io_uring 模式进行测试"></a>使用 fio 的 io_uring 模式进行测试</h3><pre><code># 开启 SQPOLL + IOPOLL
fio -threads=8 -size=32G -bs=1m -direct=1 -rw=randread -name=test -group_reporting -filename=./io.tmp -runtime 60 --ioengine=io_uring --iodepth=512 --sqthread_poll 1
# 开启 SQPOLL
fio -threads=8 -size=32G -bs=1m -direct=0 -rw=randread -name=test -group_reporting -filename=./io.tmp -runtime 60 --ioengine=io_uring --iodepth=512 --sqthread_poll 1
# 开启 IOPOLL
fio -threads=8 -size=32G -bs=1m -direct=1 -rw=randread -name=test -group_reporting -filename=./io.tmp -runtime 60 --ioengine=io_uring --iodepth=512
# 关闭 IOPOLL
fio -threads=8 -size=32G -bs=1m -direct=0 -rw=randread -name=test -group_reporting -filename=./io.tmp -runtime 60 --ioengine=io_uring --iodepth=512

# 而后使用 bcc (eBPF) 跟踪内核函数调用，生成火焰图
/usr/share/bcc/tools/profile -p `pidof fio` -f

# 也可以使用 trace-cmd 跟踪内核函数调用 (Thanks @ YangKeao)
trace-cmd record -p function_graph -F [command]</code></pre><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul>
<li>[io_uring 的第一组 patch](<a href="https://lore.kernel.org/linux-block/20190116175003.17880-6-axboe@" target="_blank" rel="noopener">https://lore.kernel.org/linux-block/20190116175003.17880-6-axboe@</a> kernel.dk/)</li>
<li><a href="https://twitter.com/YangKeao/status/1402902939832750082" target="_blank" rel="noopener">@ YangKeao 谈 ftrace</a></li>
</ul>
<p>您可以在本文对应的 <a href="https://github.com/skyzh/skyzh.github.io/pull/2" target="_blank" rel="noopener">GitHub Pull Request</a> 中评论这篇文章。</p>
<hr>
<ol>
<li><p><a href="https://elixir.bootlin.com/linux/v5.12.10/source/fs/io_uring.c#L9658" target="_blank" rel="noopener">[io_uring.c#L9658]</a> <a href="https://www.skyzh.dev/#fnref:1" target="_blank" rel="noopener">↩︎</a></p>
</li>
<li><p><code>SQ_RING</code>, <code>CQ_RING</code> 的类型均为 <code>struct io_rings</code>, 存放提交队列元素的区域是 <code>struct io_uring_sqe</code> 的数组。事实上，单个 <code>io_rings</code> 结构体既包括 SQ 信息，也包括 CQ 信息。当前的 io_uring 实现中，SQ、CQ 对应的区域指向同一个 <code>io_rings</code> 结构体。举个例子，params 中有 <code>io_sqring_offsets sq_off</code>。通过 <code>*(sq_ring_ptr + sq_off.head)</code> 和 <code>*(cq_ring_ptr + sq_off.head)</code> 都可以访问到 SQ 的队首编号。 <a href="https://www.skyzh.dev/#fnref:2" target="_blank" rel="noopener">↩︎</a></p>
</li>
<li><p><a href="https://elixir.bootlin.com/linux/v5.12.10/source/fs/io_uring.c#L860" target="_blank" rel="noopener">[io_uring.c#L860]</a> <a href="https://www.skyzh.dev/#fnref:3" target="_blank" rel="noopener">↩︎</a></p>
</li>
<li><p><a href="https://elixir.bootlin.com/linux/v5.12.10/include/uapi/linux/io_uring.h" target="_blank" rel="noopener"><code>include/uapi/linux/io_uring.h</code></a> <a href="https://www.skyzh.dev/#fnref:4" target="_blank" rel="noopener">↩︎</a></p>
</li>
<li><p>大多数情况下，这个数据会是一个指针，指向该操作对应的用户上下文。本人之前的 <a href="https://www.skyzh.dev/posts/articles/2021-01-30-async-random-read-with-rust/" target="_blank" rel="noopener">在 Rust 中实现基于 <code>io_uring</code> 的异步随机读文件</a> 就介绍了一种 <code>io_uring</code> 的用户态接口实现。<code>user_data</code> 存储 <code>UringTask</code> 结构体的内存地址。 <a href="https://www.skyzh.dev/#fnref:5" target="_blank" rel="noopener">↩︎</a></p>
</li>
<li><p>[io-wq patchset](<a href="https://lore.kernel.org/linux-block/20191024134439.28498-1-axboe@" target="_blank" rel="noopener">https://lore.kernel.org/linux-block/20191024134439.28498-1-axboe@</a> kernel.dk/T/) <a href="https://www.skyzh.dev/#fnref:6" target="_blank" rel="noopener">↩︎</a></p>
</li>
<li><p>[[PATCHSET 0/3] io_uring: support for linked SQEs](<a href="https://lore.kernel.org/linux-block/20190517214131.5925-1-axboe@" target="_blank" rel="noopener">https://lore.kernel.org/linux-block/20190517214131.5925-1-axboe@</a> kernel.dk/), [[PATCHSET v2 0/3] io_uring: support for linked SQEs](<a href="https://lore.kernel.org/linux-block/20190529202948.20833-1-axboe@" target="_blank" rel="noopener">https://lore.kernel.org/linux-block/20190529202948.20833-1-axboe@</a> kernel.dk/) <a href="https://www.skyzh.dev/#fnref:7" target="_blank" rel="noopener">↩︎</a></p>
</li>
<li><p><a href="https://elixir.bootlin.com/linux/v5.12.10/source/fs/io_uring.c#L6510" target="_blank" rel="noopener">[fs/io_uring.c#L6510]</a> <a href="https://www.skyzh.dev/#fnref:8" target="_blank" rel="noopener">↩︎</a></p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/fetched/" rel="tag"># fetched</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/13/qiwihui-pocket_readings-1131/" rel="prev" title="Async/await">
      <i class="fa fa-chevron-left"></i> Async/await
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/16/qiwihui-pocket_readings-1133/" rel="next" title="


如何阅读一份代码？ ">
      


如何阅读一份代码？  <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Comments"><span class="nav-number">1.</span> <span class="nav-text">Comments</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io-uring-的接口与实现"><span class="nav-number"></span> <span class="nav-text">io_uring 的接口与实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#io-uring-的接口与实现-1"><span class="nav-number"></span> <span class="nav-text">io_uring 的接口与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number"></span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io-uring-的-用户态-API"><span class="nav-number"></span> <span class="nav-text">io_uring 的 用户态 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化-io-uring"><span class="nav-number">1.</span> <span class="nav-text">初始化 io_uring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务的描述"><span class="nav-number">2.</span> <span class="nav-text">任务的描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作的定义与实现"><span class="nav-number">2.1.</span> <span class="nav-text">操作的定义与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作信息的传递"><span class="nav-number">2.2.</span> <span class="nav-text">操作信息的传递</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务的提交与完成"><span class="nav-number">3.</span> <span class="nav-text">任务的提交与完成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io-uring-的实现"><span class="nav-number"></span> <span class="nav-text">io_uring 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于内核线程的任务执行"><span class="nav-number">1.</span> <span class="nav-text">基于内核线程的任务执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于轮询的任务执行"><span class="nav-number">2.</span> <span class="nav-text">基于轮询的任务执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io-uring-的任务依赖管理"><span class="nav-number"></span> <span class="nav-text">io_uring 的任务依赖管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-number"></span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-fio-的-io-uring-模式进行测试"><span class="nav-number">1.</span> <span class="nav-text">使用 fio 的 io_uring 模式进行测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关链接"><span class="nav-number">2.</span> <span class="nav-text">相关链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">qiwihui</p>
  <div class="site-description" itemprop="description">个人阅读清单记录博客，并不代表个人观点。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qiwihui</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
