<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pocket.qiwihui.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型 - 古明地盆 - 博客园">
<meta property="og:type" content="article">
<meta property="og:title" content="《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型 - 古明地盆 - 博客园">
<meta property="og:url" content="http://pocket.qiwihui.com/2021/02/16/qiwihui-pocket_readings-997/index.html">
<meta property="og:site_name" content="Pocket Readings">
<meta property="og:description" content="《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型 - 古明地盆 - 博客园">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145015494-1262221800.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145024809-191289177.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145034276-763029316.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145044778-1870390811.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145054041-1031552242.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145106278-810247034.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145116270-255429950.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145126645-589870789.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145138622-2079722484.png">
<meta property="article:published_time" content="2021-02-16T14:06:20.000Z">
<meta property="article:modified_time" content="2021-07-21T13:58:31.438Z">
<meta property="article:author" content="qiwihui">
<meta property="article:tag" content="fetched">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145015494-1262221800.png">

<link rel="canonical" href="http://pocket.qiwihui.com/2021/02/16/qiwihui-pocket_readings-997/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型 - 古明地盆 - 博客园 | Pocket Readings</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pocket Readings</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人阅读清单记录博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pocket.qiwihui.com/2021/02/16/qiwihui-pocket_readings-997/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="qiwihui">
      <meta itemprop="description" content="个人阅读清单记录博客，并不代表个人观点。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pocket Readings">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型 - 古明地盆 - 博客园
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-16 14:06:20" itemprop="dateCreated datePublished" datetime="2021-02-16T14:06:20+00:00">2021-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-21 13:58:31" itemprop="dateModified" datetime="2021-07-21T13:58:31+00:00">2021-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">2019阅读</span></a>
                </span>
            </span>

          
            <div class="post-description">《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型 - 古明地盆 - 博客园</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Python&#20013;&#19968;&#20999;&#30342;&#23545;&#35937; &#20851;&#20110;Python&#65292;&#20320;&#32943;&#23450;&#21548;&#36807;&#36825;&#20040;&#19968;&#21477;&#35805;&#65306;”Python&#20013;&#19968;&#20999;&#30342;&#23545;&#35937;”&#12290;&#27809;&#38169;&#65292;&#22312;Python&#30340;&#19990;&#30028;&#37324;&#65292;&#19968;&#20999;&#37117;&#26159;&#23545;&#35937;&#12290;&#25972;&#22411;&#26159;&#19968;&#20010;&#23545;&#35937;&#12289;&#23383;&#31526;&#20018;&#26159;&#19968;&#20010;&#23545;&#35937;&#12289;&#23383;&#20856;&#26159;&#19968;&#20010;&#23545;&#35937;&#65292;&#29978;&#33267;int&#12289;str&#12289;list&#31561;&#31561;&#65292;&#20877;&#21152;&#19978;&#25105;&#20204;&#20351;&#29992;class&#33258;&#23450;&#20041;&#30340;<br><br><br><br>Tags:<br><br><br><br>via Pocket <a href="https://ift.tt/3jToOZ6" target="_blank" rel="noopener">https://ift.tt/3jToOZ6</a> original site<br><br><br><br>February 16, 2021 at 10:02PM</p>
<h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><hr>
<blockquote>
<p>from: <a href="https://github.com/qiwihui/pocket_readings/issues/997#issuecomment-792583056" target="_blank" rel="noopener"><strong>github-actions[bot]</strong></a> on: <strong>3/8/2021</strong></p>
</blockquote>
<h2 id="《深度剖析CPython解释器》1-Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型-古明地盆-博客园"><a href="#《深度剖析CPython解释器》1-Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型-古明地盆-博客园" class="headerlink" title="《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型 - 古明地盆 - 博客园"></a>《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型 - 古明地盆 - 博客园</h2><h1 id="《深度剖析CPython解释器》1-Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型"><a href="#《深度剖析CPython解释器》1-Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型" class="headerlink" title="《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型"></a><a href="https://www.cnblogs.com/traditional/p/13391098.html" target="_blank" rel="noopener">《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型</a></h1><h2 id="Python中一切皆对象"><a href="#Python中一切皆对象" class="headerlink" title="Python中一切皆对象"></a>Python中一切皆对象</h2><p><strong>关于Python，你肯定听过这么一句话：”Python中一切皆对象”。没错，在Python的世界里，一切都是对象。整型是一个对象、字符串是一个对象、字典是一个对象，甚至int、str、list等等，再加上我们使用class自定义的类，它们也是对象。</strong></p>
<blockquote>
<p><strong>像int、str、list等基本类型，以及我们自定义的类，由于它们可以表示类型，因此我们称之为**</strong>类型对象<strong><strong>；类型对象实例化得到的对象，我们称之为</strong></strong>实例对象<strong>**。不管是哪种对象，它们都属于对象。</strong></p>
</blockquote>
<p><strong>因此Python中面向对象的理念贯彻的非常彻底，面向对象中的”类”和”对象”在Python中都是通过”对象”实现的。</strong></p>
<blockquote>
<p><strong>在面向对象理论中，存在着”类”和”对象”两个概念，像int、dict、tuple、以及使用class关键字自定义的类型对象实现了面向对象理论中”类”的概念，而123、(1, 2, 3)，”xxx”等等这些实例对象则实现了面向对象理论中”对象”的概念。但是在Python中，面向对象的”类”和”对象”都是通过对象实现的。</strong></p>
</blockquote>
<p><strong>我们举个栗子：</strong></p>
<pre><code>&gt;&gt;&gt; # int它是一个类，因此它属于类型对象, 类型对象实例化得到的对象属于实例对象
&gt;&gt;&gt; int  
&lt;class &apos;int&apos;&gt;
&gt;&gt;&gt; int(&apos;0123&apos;) 
123
&gt;&gt;&gt;</code></pre><p><strong>因此可以用一张图来描述面向对象在Python中的体现：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145015494-1262221800.png" alt=""></p>
<h2 id="类型、对象体系"><a href="#类型、对象体系" class="headerlink" title="类型、对象体系"></a>类型、对象体系</h2><p><strong>a是一个整数(实例对象)，其类型是int(类型对象)。</strong></p>
<pre><code>&gt;&gt;&gt; a = 123
&gt;&gt;&gt; a
123
&gt;&gt;&gt; type(a)
&lt;class &apos;int&apos;&gt;
&gt;&gt;&gt; isinstance(a, int)
True
&gt;&gt;&gt;</code></pre><p><strong>但是问题来了，按照面向对象的理论来说，对象是由类实例化得到的，这在Python中也是适用的。既然是对象，那么就必定有一个类来实例化它，换句话说对象一定要有类型。至于一个对象的类型是什么，就看这个对象是被谁实例化的，被谁实例化那么类型就是谁。而我们说Python中一切皆对象，所以像int、str、tuple这些内置的类型也是具有相应的类型的，那么它们的类型又是谁呢？</strong></p>
<p><strong>我们使用type函数查看一下就好了。</strong></p>
<pre><code>&gt;&gt;&gt; type(int)
&lt;class &apos;type&apos;&gt;
&gt;&gt;&gt; type(str)
&lt;class &apos;type&apos;&gt;
&gt;&gt;&gt; type(dict)
&lt;class &apos;type&apos;&gt;
&gt;&gt;&gt; type(type)
&lt;class &apos;type&apos;&gt;
&gt;&gt;&gt;</code></pre><p><strong>我们看到类型对象的类型，无一例外都是type。type应该是初学Python的时候就接触了，当时使用type都是为了查看一个对象的类型，然而type的作用远没有这么简单，我们后面会说，总之我们目前看到类型对象的类型是type。</strong></p>
<p><strong>所以int、str等类型对象是type的对象，而type我们也称其为**</strong>元类<strong>**，表示类型对象的类型。至于type本身，它的类型还是type，所以它连自己都没放过，把自己都变成自己的对象了。</strong></p>
<blockquote>
<p><strong>因此在Python中，你能看到的任何对象都是有类型的，我们可以使用type函数查看，也可以获取该对象的__class__属性查看。</strong></p>
<p><strong>所以：实例对象、类型对象、元类，Python中任何一个对象都逃不过这三种身份。</strong></p>
</blockquote>
<p><strong>Python中还有一个特殊的类型(对象)，叫做object，它是所有类型对象的基类。不管是什么类，内置的类也好，我们自定义的类也罢，它们都继承自object。因此，object是所有类型对象的”基类”、或者说”父类”。</strong></p>
<pre><code>&gt;&gt;&gt; issubclass(int, object)
True
&gt;&gt;&gt;</code></pre><p><strong>因此，综合以上关系，我们可以得到下面这张关系图：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145024809-191289177.png" alt=""></p>
<p><strong>我们自定义的类型也是如此，举个栗子：</strong></p>
<pre><code>class Female:
    pass


print(type(Female))  # &lt;class &apos;type&apos;&gt;
print(issubclass(Female, object))  # True</code></pre><p><strong>在Python3中，自定义的类即使不显式的继承object，也会默认继承自object。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145034276-763029316.png" alt=""></p>
<p><strong>那么我们自定义再自定义一个子类，继承自Female呢？</strong></p>
<pre><code>class Female:
    pass


class Girl(Female):
    pass


# 自定义类的类型都是type
print(type(Girl))  # &lt;class &apos;type&apos;&gt;

# 但Girl继承自Female, 所以它是Female的子类
print(issubclass(Girl, Female))  # True
# 而Female继承自object, 所以Girl也是object的子类
print(issubclass(Girl, object))  # True


# 这里需要额外多提一句实例对象, 我们之前使用type得到的都是该类的类型对象
# 换句话说谁实例化得到的它, 那么对它使用type得到的就是谁
print(type(Girl()))  # &lt;class &apos;__main__.Girl&apos;&gt;
print(type(Female()))  # &lt;class &apos;__main__.Female&apos;&gt;

# 但是我们说Girl的父类是Female, Female的父类是object
# 所以Girl的实例对象也是Female和object的实例对象, Female的实例对象也是object的实例对象
print(isinstance(Girl(), Female))  # True
print(isinstance(Girl(), object))  # True</code></pre><p><strong>因此上面那张关系图就可以变成下面这样：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145044778-1870390811.png" alt=""></p>
<p><strong>我们说可以使用type和__class__查看一个对象的类型，并且还可以通过isinstance来判断该对象是不是某个已知类型的实例对象；那如果想查看一个类型对象都继承了哪些类该怎么做呢？我们目前都是使用issubclass来判断某个类型对象是不是另一个已知类型对象的子类，那么可不可以直接获取某个类型对象都继承了哪些类呢？</strong></p>
<p><strong>答案是可以的，方法有三种，我们分别来看一下：</strong></p>
<pre><code>class A: pass

class B: pass

class C(A): pass

class D(B, C): pass

# 首先D继承自B和C, C又继承A, 我们现在要来查看D继承的父类
# 方法一: 使用__base__
print(D.__base__)  # &lt;class &apos;__main__.B&apos;&gt;

# 方法二: 使用__bases__
print(D.__bases__)  # (&lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;)

# 方法三: 使用__mro__
print(D.__mro__)
# (&lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;object&apos;&gt;)</code></pre><ul>
<li><code>__base__: 如果继承了多个类, 那么只显示继承的第一个类, 没有显示继承则返回一个&lt;class &#39;object&#39;&gt;;</code></li>
<li><code>__bases__: 返回一个元组, 会显示所有直接继承的父类, 如果没有显示的继承, 则返回(&lt;class &#39;object&#39;&gt;,);</code></li>
<li><code>__mro__: mro表示Method Resolution Order, 表示方法查找顺序, 会从自身除法, 找到最顶层的父类, 因此返回自身、继承的基类、以及基类继承的基类, 一直找到object;</code></li>
</ul>
<p><strong>最后我们来看一下type和object，估计这两个老铁之间的关系会让很多人感到困惑。</strong></p>
<p><strong>我们说type是所有类的元类，而object是所有的基类，这就说明type是要继承自object的，而object的类型是type。</strong></p>
<pre><code>&gt;&gt;&gt; type.__base__
&lt;class &apos;object&apos;&gt;
&gt;&gt;&gt; object.__class__
&lt;class &apos;type&apos;&gt;
&gt;&gt;&gt;</code></pre><p><strong>这就怪了，这难道不是一个先有鸡还是先有蛋的问题吗？其实不是的，这两个对象是共存的，它们之间的定义其实是互相依赖的。至于到底是怎么肥事，我们后面在看解释器源码的时候就会很清晰了。</strong></p>
<p><strong>总之目前记住两点：</strong></p>
<ul>
<li><code>1. type站在类型金字塔的最顶端, 任何的对象按照类型追根溯源, 最终得到的都是type;</code></li>
<li><code>2. object站在继承金字塔的最顶端, 任何的类型对象按照继承追根溯源, 最终得到的都是object;</code></li>
</ul>
<blockquote>
<p><strong>我们说type的类型还是type，但是object的基类则不再是object，而是一个None。为什么呢？其实答案很简单，我们说Python在查找属性或方法的时候，会回溯继承链，自身如果没有的话，就会按照__mro__指定的顺序去基类中查找。所以继承链一定会有一个终点，否则就会像没有出口的递归一样出现死循环了。</strong></p>
</blockquote>
<p><strong>最后将上面那张关系图再完善一下的话：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145054041-1031552242.png" alt=""></p>
<p><strong>因此上面这种图才算是完整，其实只看这张图我们就能解读出很多信息。比如：实例对象的类型是类型对象，类型对象的类型是元类；所有的类型对象的基类都收敛于object，所有对象的类型都收敛于type。因此Python算是将一切皆对象的理念贯彻到了极致，也正因为如此，Python才具有如此优秀的动态特性。</strong></p>
<blockquote>
<p><strong>事实上，目前介绍的有些基础了，但Python中的对象的概念确实非常重要。为了后面再分析源码的时候能够更轻松，因此我们有必要系统地回顾一下，并且上面的关系图会使我们在后面的学习变得轻松。因为等到看解释器的时候，我们可就没完了，就不那么轻松了(なん～～～てね)。</strong></p>
</blockquote>
<h2 id="Python中的变量只是个名字"><a href="#Python中的变量只是个名字" class="headerlink" title="Python中的变量只是个名字"></a>Python中的变量只是个名字</h2><p><strong>Python中的变量只是个名字，站在C语言的角度来说的话，Python中的变量存储的只是对象的内存地址，或者说指针，这个指针指向的内存存储的才是对象。</strong></p>
<blockquote>
<p><strong>所以在Python中，我们都说变量指向了某个对象。在其它静态语言中，变量相当于是为某块内存起的别名，获取变量等于获取这块内存所存储的值。而Python中变量代表的内存存储的不是对象，只是对象的指针。</strong></p>
</blockquote>
<p><strong>我们用两段代码，一段C语言的代码，一段Python的代码，来看一下差别。</strong></p>
<pre><code>#include &lt;stdio.h&gt;

void main()
{
    int a = 123;
    printf(&quot;address of a = %p\n&quot;, &amp;a);

    a = 456
    printf(&quot;address of a = %p\n&quot;, &amp;a);
}
//输出结果
/*
address of a = 0x7fffa94de03c
address of a = 0x7fffa94de03c
*/</code></pre><p><strong>我们看到前后输出的地址是一样的，再来看看Python的。</strong></p>
<pre><code>a = 666
print(hex(id(a)))  # 0x1b1333394f0

a = 667
print(hex(id(a)))  # 0x1b133339510</code></pre><p><strong>然而我们看到Python中变量a的地址前后发生了变化，我们分析一下原因。</strong></p>
<p><strong>首先在C中，创建一个变量的时候必须规定好类型，比如int a = 666，那么变量a就是int类型，以后在所处的作用域中就不可以变了。如果这时候，再设置a = 777，那么等于是把内存中存储的666换成777，a的地址和类型是不会变化的。</strong></p>
<p><strong>而在Python中，a = 666等于是先开辟一块内存，存储的值为666，然后让变量a指向这片内存，或者说让变量a存储这块内存的指针。然后a = 777的时候，再开辟一块内存，然后让a指向存储777的内存，由于是两块不同的内存，所以它们的地址是不一样的。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145106278-810247034.png" alt=""></p>
<blockquote>
<p><strong>所以Python中的变量只是一个和对象关联的名字罢了，它代表的是对象的指针。换句话说Python中的变量就是个便利贴，可以贴在任何对象上，一旦贴上去了，就代表这个对象被引用了。</strong></p>
</blockquote>
<p><strong>我们再来看看变量之间的传递，在Python中是如何体现的。</strong></p>
<pre><code>a = 666
print(hex(id(a)))  # 0x1e6c51e3cf0

b = a
print(hex(id(b)))  # 0x1e6c51e3cf0</code></pre><p><strong>我们看到打印的地址是一样的，我们再用一张图解释一下。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145116270-255429950.png" alt=""></p>
<p><strong>我们说a = 666的时候，先开辟一份内存，再让a存储对应内存的指针；然后b = a的时候，会把a的地址拷贝一份给b，所以b存储了和a相同的地址，它们都指向了同一个对象。</strong></p>
<blockquote>
<p><strong>因此说Python是值传递、或者引用传递都是不准确的，准确的说Python是**</strong>变量之间的赋值传递，对象之间的引用传递。**</p>
<p><strong>因为Python中的变量本质上就是一个指针，所以在b = a的时候，等于把a指向的对象的地址（a本身）拷贝一份给b，所以对于变量来说是赋值传递；然后a和b又都是指向对象的指针，因此对于对象来说是引用传递。</strong></p>
</blockquote>
<p><strong>另外还有最关键的一点，我们说Python中的变量是一个指针，**</strong>当传递一个变量的时候，传递的是指针；但是在操作一个变量的时候，会操作变量指向的内存。**</p>
<p><strong>所以id(a)获取的不是a的地址，而是a指向的内存的地址(在底层其实就是a)，同理b = a，是将a本身，或者说将a存储的、指向某个具体的对象的地址传递给了b。</strong></p>
<blockquote>
<p><strong>另外在C的层面上，a和b属于指针变量，那么a和b有没有地址呢？显然是有的，只不过在Python中你是看不到的，Python解释器只允许你看到对象的地址。</strong></p>
</blockquote>
<p><strong>最后提一下变量的类型</strong></p>
<p><strong>我们说变量的类型其实不是很准确，应该是变量指向(引用)的对象的类型，因为我们说Python中变量是个指针，操作指针会操作指针指向的内存，所以我们使用type(a)查看的是变量a指向的内存的类型，当然为了方便也会直接说变量的类型，理解就行。那么问题来了，我们在创建一个变量的时候，并没有显示的指定类型啊，但Python显然是有类型的，那么Python是如何判断一个变量指向的是什么类型的数据呢？</strong></p>
<p><strong>答案是：解释器是通过靠猜的方式，通过你赋的值(或者说变量引用的值)来推断类型。所以在Python中，如果你想创建一个变量，那么必须在创建变量的时候同时赋值，否则解释器就不知道这个变量指向的数据是什么类型。所以Python是先创建相应的值，这个值在C中对应一个结构体，结构体里面有一个成员专门用来存储该值对应的类型。当创建完值之后，再让这个变量指向它，所以Python中是先有值后有变量。但显然C中不是这样的，因为C中变量代表的内存所存储的就是具体的值，所以C中可以直接声明一个变量的同时不赋值。因为C要求声明变量的同时必须指定类型，所以声明变量的同时，其类型和内存大小就已经固定了。而Python中变量代表的内存是个指针，它只是指向了某个对象，所以由于其便利贴的特性，可以贴在任意对象上面，但是不管贴在哪个对象，你都必须先有对象才可以，不然变量贴谁去？</strong></p>
<p><strong>另外，尽管Python在创建变量的时候不需要指定类型，但Python是强类型语言，强类型语言，强类型语言，重要的事情说三遍。而且是动态强类型，因为类型的强弱和是否需要显示声明类型之间没有关系。</strong></p>
<h2 id="可变对象与不可变对象"><a href="#可变对象与不可变对象" class="headerlink" title="可变对象与不可变对象"></a>可变对象与不可变对象</h2><p><strong>我们说一个对象其实就是一片被分配的内存空间，内存中存储了相应的值，不过这些空间可以是连续的，也可以是不连续的。</strong></p>
<p><strong>不可变对象一旦创建，其内存中存储的值就不可以再修改了。如果想修改，只能创建一个新的对象，然后让变量指向新的对象，所以前后的地址会发生改变。而可变对象在创建之后，其存储的值可以动态修改。</strong></p>
<p><strong>像整型就是一个不可变对象。</strong></p>
<pre><code>&gt;&gt;&gt; a = 666
&gt;&gt;&gt; id(a)
1365442984464
&gt;&gt;&gt; a += 1
&gt;&gt;&gt; id(a)
1365444032848
&gt;&gt;&gt;</code></pre><p><strong>我们看到在对a执行+1操作时，前后地址发生了变化，所以整型不支持本地修改，因此是一个不可变对象；</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145126645-589870789.png" alt=""></p>
<p><strong>原来a = 666，而我们说操作一个变量等于操作这个变量指向的内存，所以a+=1，会将a指向的整型对象666和1进行加法运算，得到667。所以会开辟新的空间来存储这个667，然后让a指向这片新的空间，至于原来的666所占的空间怎么办，Python解释器会看它的引用计数，如果不为0代表还有变量引用(指向)它，如果为0证明没有变量引用了，所以会被回收。</strong></p>
<p><strong>关于引用计数，我们后面会详细说，目前只需要知道当一个对象被一个变量引用的时候，那么该对象的引用计数就会加1。有几个变量引用，那么它的引用计数就是几。</strong></p>
<blockquote>
<p><strong>可能有人觉得，每次都要创建新对象，销毁旧对象，效率肯定会很低吧。事实上确实如此，但是后面我们会从源码的角度上来看Python如何通过小整数对象池等手段进行优化。</strong></p>
</blockquote>
<p><strong>而列表是一个可变对象，它是可以修改的。</strong></p>
<blockquote>
<p><strong>这里先多提一句，Python中的对象本质上就是C中malloc函数为结构体实例在堆区申请的一块内存。Python中的任何对象在C中都会对应一个结构体，这个结构体除了存放具体的值之外，还存放了一些额外的信息，这个我们在剖析Python中的内置类型的实例对象的时候会细说。</strong></p>
</blockquote>
<p><strong>首先Python中列表，当然不光是列表，还有元组、集合，这些容器它们的内部存储的也不是具体的对象，而是对象的指针。比如：lst = [1, 2, 3]，你以为lst存储的是三个整型对象吗？其实不是的，lst存储的是三个整型对象的指针，当我们使用lst[0]的时候，拿到的是第一个元素的指针，但是操作(比如print)的时候会自动操作(print)指针指向的内存。</strong></p>
<p><strong>不知道你是否思考过，Python底层是C来实现的，所以Python中的列表的实现必然要借助C中的数组。可我们知道C中的数组里面的所有元素的类型必须一致，但列表却可以存放任意的元素，因此从这个角度来讲，列表里面的元素它就就不可能是对象，因为不同的对象在底层对应的结构体是不同的，所以这个元素只能是指针。</strong></p>
<p><strong>可能有人又好奇了，不同对象的指针也是不同的啊，是的，但C中的指针是可以转化的。Python底层将所有对象的指针，都转成了PyObject的指针，这样不就是同一种类型的指针了吗？关于这个PyObject，它是我们后面要剖析的重中之重，这个PyObject贯穿了我们的整个系列。目前只需要知道Python中的列表存储的值，在底层是通过一个PyObject *类型的数据来维护的。</strong></p>
<pre><code>&gt;&gt;&gt; lst = [1, 2, 3]
&gt;&gt;&gt; id(lst)
1365442893952
&gt;&gt;&gt; lst.append(4)
&gt;&gt;&gt; lst
[1, 2, 3, 4]
&gt;&gt;&gt; id(lst)
1365442893952
&gt;&gt;&gt;</code></pre><p><strong>我们看到列表在添加元素的时候，前后地址并没有改变。列表在C中是通过PyListObject实现的，我们在介绍列表的时候会细说。这个PyListObject内部除了一些基本信息之外，还有一个成员叫ob_item，它是一个PyObject的二级指针，指向了我们刚才说的PyObject *类型的数组的首个元素的地址。</strong></p>
<p><strong>结构图如下：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1229382/202007/1229382-20200728145138622-2079722484.png" alt=""></p>
<p><strong>显然图中的指针数组是用来存储具体的对象的指针的，每一个指针都指向了相应的对象(这里是整型对象)。可能有人注意到，整型对象的顺序有点怪，其实我是故意这么画的。因为PyObject *数组内部的元素是连续且有顺序的，但是指向的整型对象则是存储在堆区的，它们的位置是任意性的。但是不管这些整型对象存储在堆区的什么位置，它们和数组中的指针都是一一对应的，我们通过索引是可以正确获取到指向的对象的。</strong></p>
<p><strong>另外我们还可以看到一个现象，那就是Python中的列表在底层是分开存储的，因为PyListObject结构体实例并没有存储相应的指针数组，而是存储了指向这个指针数组的二级指针。显然我们添加、删除、修改元素等操作，都是通过这个二级指针来间接操作这个指针数组。</strong></p>
<p><strong>为什么要这么做？</strong></p>
<p><strong>因为在Python中一个对象一旦被创建，那么它在内存中的大小就不可以变了。所以这就意味着那些可以容纳可变长度数据的可变对象，要在内部维护一个指向可变大小的内存区域的指针。而我们看到PyListObject正是这么做的，指针数组的长度、内存大小是可变的，所以PyListObject内部并没有直接存储它，而是存储了指向它的二级指针。但是Python在计算内存大小的时候是会将这个指针数组也算进去的，所以Python中列表的大小是可变的，但是底层对应的PyListObject实例的大小是不变的，因为可变长度的指针数组没有存在PyListObject里面。但为什么要这么设计呢？</strong></p>
<blockquote>
<p><strong>这么做的原因就在于，遵循这样的规则可以使通过指针维护对象的工作变得非常简单。一旦允许对象的大小可在运行期改变，那么我们就可以考虑如下场景。在内存中有对象A，并且其后面紧跟着对象B。如果运行的某个时候，A的大小增大了，这就意味着必须将A整个移动到内存中的其他位置，否则A增大的部分会覆盖掉原本属于B的数据。只要将A移动到内存的其他位置，那么所有指向A的指针就必须立即得到更新。可想而知这样的工作是多么的繁琐，而通过一个指针去操作就变得简单多了。</strong></p>
</blockquote>
<h2 id="定长对象与变长对象"><a href="#定长对象与变长对象" class="headerlink" title="定长对象与变长对象"></a>定长对象与变长对象</h2><p><strong>Python中一个对象占用的内存有多大呢？相同类型的实例对象的大小是否相同呢？试一下就知道了，我们可以通过sys模块中getsizeof函数查看一个对象所占的内存。</strong></p>
<pre><code>import sys

print(sys.getsizeof(0))  # 24
print(sys.getsizeof(1))  # 28
print(sys.getsizeof(2 &lt;&lt; 33))  # 32


print(sys.getsizeof(0.))  # 24
print(sys.getsizeof(3.14))  # 24
print(sys.getsizeof((2 &lt;&lt; 33) + 3.14))  # 24</code></pre><p><strong>我们看到整型对象的大小不同，所占的内存也不同，像这种内存大小不固定的对象，我们称之为变长对象；而浮点数所占的内存都是一样的，像这种内存大小固定的对象，我们称之为定长对象。</strong></p>
<blockquote>
<p><strong>至于Python是如何计算对象所占的内存，我们在剖析具体对象的时候会说，因为这要涉及到底层对应的结构体。</strong></p>
</blockquote>
<p><strong>而且我们知道Python中的整数是不会溢出的，而C中的整型显然是有最大范围的，那么Python是如何做到的呢？答案是Python在底层是通过C的32位整型数组来存储自身的整型对象的，通过多个32位整型组合起来，以支持存储更大的数值，所以整型越大，就需要越多的32位整数。而32位整数是4字节，所以我们上面代码中的那些整型，都是4字节、4字节的增长。</strong></p>
<p><strong>当然Python中的对象在底层都是一个结构体，这个结构体中除了维护具体的值之外，还有其它的成员信息，在计算内存大小的时候，它们也是要考虑在内的，当然这些我们后面会说。</strong></p>
<p><strong>而浮点数的大小是不变的，因为Python的浮点数的值在C中是通过一个double来维护的。而C中的值的类型一旦确定，大小就不变了，所以Python的float也是不变的。</strong></p>
<p><strong>但是既然是固定的类型，肯定范围是有限的，所以当浮点数不断增大，会牺牲精度来进行存储。如果实在过大，那么会抛出OverFlowError。</strong></p>
<pre><code>&gt;&gt;&gt; int(1000000000000000000000000000000000.)  # 牺牲了精度
999999999999999945575230987042816
&gt;&gt;&gt; 10 ** 1000  # 不会溢出
1000000000000000......
&gt;&gt;&gt;
&gt;&gt;&gt; 10. ** 1000  # 报错了
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
OverflowError: (34, &apos;Result too large&apos;)
&gt;&gt;&gt;</code></pre><p><strong>还有字符串，字符串毫无疑问肯定是可变对象，因为长度不同大小不同。</strong></p>
<pre><code>import sys

print(sys.getsizeof(&quot;a&quot;))  # 50
print(sys.getsizeof(&quot;abc&quot;))  # 52</code></pre><p><strong>我们看到多了两个字符，多了两个字节，这很好理解。但是这些说明了一个空字符串要占49个字节，我们来看一下。</strong></p>
<pre><code>import sys

print(sys.getsizeof(&quot;&quot;))  # 49</code></pre><p><strong>显然是的，显然这49个字节是用来维护其它成员信息的，因为底层的结构体除了维护具体的值之外，还要维护其它的信息，比如：引用计数等等，这些在分析源码的时候会详细说。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>我们这一节介绍了Python中的对象体系，我们说Python中一切皆对象，类型对象和实例对象都属于对象；还说了对象的种类，根据是否支持本地修改可以分为可变对象和不可变对象，根据占用的内存是否不变可以分为定长对象和变长对象；还说了Python中变量的本质，Python中的变量本质上是一个指针，而变量的名字则存储在对应的名字空间(或者说命名空间)中，当然名字空间我们没有说，是因为这些在后续系列会详细说<code>(又是后续, 不管咋样, 坑先挖出来)</code>，不过这里可以先补充一下。</strong></p>
<p><strong>名字空间分为：全局名字空间<code>(存储全局变量)</code>、局部名字空间<code>(存储局部变量)</code>、闭包名字空间<code>(存储闭包变量)</code>、内建名字空间<code>(存储内置变量, 比如int、str, 它们都在这里)</code>，而名字空间又分为静态名字空间和动态名字空间：比如局部名字空间，因为函数中的局部变量在编译的时候就可以确定，所以函数对应的局部名字空间使用一个数组存储；而全局变量在运行时可以进行动态添加、删除，因此全局名字空间使用的是一个字典来保存，字典的key就是变量的名字<code>(依旧是个指针，底层是指向字符串(PyUnicodeObject)的指针)</code>，字典的value就是变量指向的对象的指针(或者说变量本身)。</strong></p>
<pre><code>a = 123
b = &quot;xxx&quot;

# 通过globals()即可获取全局名字空间
print(globals())  #{..., &apos;a&apos;: 123, &apos;b&apos;: &apos;xxx&apos;}

# 我们看到虽然显示的是变量名和变量指向的值
# 但是在底层，字典存储的键值对也是指向具体对象的指针
# 只不过我们说操作指针会操作指向的内存，所以这里print打印之后，显示的也是具体的值，但是存储的是指针
# 至于对象本身，则存储在堆区，并且被指针指向



#  此外，我们往全局名字空间中设置一个键值对，也等价于创建了一个全局变量
globals()[&quot;c&quot;] = &quot;hello&quot;
print(c)  # hello


# 此外这个全局名字空间是唯一的，即使你把它放在函数中也是一样
def foo():
    globals()[&quot;d&quot;] = &quot;古明地觉&quot;


# foo一旦执行，{&quot;d&quot;: &quot;古明地觉&quot;}就设置进了全局名字空间中
foo()  
print(d)  # 古明地觉</code></pre><p><strong>怎么样，是不是有点神奇呢？所以名字空间是Python作用域的灵魂，它严格限制了变量的活动范围，当然这些后面都会慢慢的说，因为饭要一口一口吃。因此这一节算是回顾基础吧，虽说是基础但是其实也涉及到了一些解释器的知识，不过这一关我们迟早是要过的，所以就提前接触一下吧。</strong></p>
<p>posted @  2020-07-28 14:53  <a href="https://www.cnblogs.com/traditional/" target="_blank" rel="noopener">古明地盆</a>  阅读(973)  评论(1)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=13391098" target="_blank" rel="noopener">编辑</a>  <a href="https://www.cnblogs.com/traditional/p/13391098.html" target="_blank" rel="noopener">收藏</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/fetched/" rel="tag"># fetched</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/13/qiwihui-pocket_readings-995/" rel="prev" title="


惊了，数据库原来还可以这样实现秒级扩容？ ">
      <i class="fa fa-chevron-left"></i> 


惊了，数据库原来还可以这样实现秒级扩容？ 
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/16/qiwihui-pocket_readings-998/" rel="next" title="《深度剖析CPython解释器》2.  解密PyObject、PyVarObject、PyTypeObject在Python对象体系中所代表的含义，用CPython来总结Python中type和object之间的关系 - 古明地盆 - 博客园">
      《深度剖析CPython解释器》2.  解密PyObject、PyVarObject、PyTypeObject在Python对象体系中所代表的含义，用CPython来总结Python中type和object之间的关系 - 古明地盆 - 博客园 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Comments"><span class="nav-number">1.</span> <span class="nav-text">Comments</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#《深度剖析CPython解释器》1-Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型-古明地盆-博客园"><span class="nav-number"></span> <span class="nav-text">《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型 - 古明地盆 - 博客园</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#《深度剖析CPython解释器》1-Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型"><span class="nav-number"></span> <span class="nav-text">《深度剖析CPython解释器》1. Python中一切皆对象，这里的对象究竟是什么？解密Python中的对象模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Python中一切皆对象"><span class="nav-number"></span> <span class="nav-text">Python中一切皆对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型、对象体系"><span class="nav-number"></span> <span class="nav-text">类型、对象体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python中的变量只是个名字"><span class="nav-number"></span> <span class="nav-text">Python中的变量只是个名字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可变对象与不可变对象"><span class="nav-number"></span> <span class="nav-text">可变对象与不可变对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定长对象与变长对象"><span class="nav-number"></span> <span class="nav-text">定长对象与变长对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number"></span> <span class="nav-text">小结</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">qiwihui</p>
  <div class="site-description" itemprop="description">个人阅读清单记录博客，并不代表个人观点。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qiwihui</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
